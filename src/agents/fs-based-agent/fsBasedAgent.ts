import { HumanMessage, SystemMessage, AIMessage } from "@langchain/core/messages";
import type { RunAgentFunction } from "../../core/CoreDef.js";
import { getLLM } from "../../utils/llm.js";
import { fsBasedAgentPrompt } from "./fsBasedAgent.prompt.js";
import { createLSTool } from "./tools/lsTool.js";
import { createGlobTool } from "./tools/globTool.js";
import { createGrepTool } from "./tools/grepTool.js";
import { createReadFileTool } from "./tools/readFileTool.js";
import { createReadManyFilesTool } from "./tools/readManyFilesTool.js";
import { uniqueIdMiddleware, ensureUniqueId } from "../../utils/uniqueIdMiddleware.js";
import { StateGraph, START, END, MessagesAnnotation, GraphRecursionError } from "@langchain/langgraph";
import { createAgent } from "langchain";

type FsBasedAgentParams = {
    modelName: string;
    apiKey: string;
    baseURL: string;
    rootPath: string;
    query: string;
};

export const runFsBasedAgent = (async (params: FsBasedAgentParams) => {
    // Create all file system tools with the rootPath
    const tools = [
        createLSTool({ rootPath: params.rootPath }),
        createGlobTool({ rootPath: params.rootPath }),
        createGrepTool({ rootPath: params.rootPath }),
        createReadFileTool({ rootPath: params.rootPath }),
        createReadManyFilesTool({ rootPath: params.rootPath }),
    ];

    // 1. Create the sub-agent
    const subAgent = createAgent({
        model: getLLM(params.modelName, params.apiKey, params.baseURL),
        tools,
        middleware: [uniqueIdMiddleware],
    });

    // Special marker to indicate recursion error
    const RECURSION_ERROR_MARKER = "__RECURSION_LIMIT_REACHED__";

    // 2. Define the Node that calls the Sub-Agent
    const callSubAgent = async (state: typeof MessagesAnnotation.State) => {
        const { messages } = state;
        const inputs = [
            new SystemMessage(fsBasedAgentPrompt),
            ...messages
        ];
        
        let lastState: any = null;

        try {
            // Use stream to capture intermediate states
            // We use a loop to consume the stream and keep the last emitted state
            const stream = await subAgent.stream(
                { messages: inputs },
                { recursionLimit: 10 }
            );

            for await (const chunk of stream) {
                lastState = chunk;
            }

            // Success case: return the last message as before
            if (lastState && lastState.messages && lastState.messages.length > 0) {
                const lastMessage = lastState.messages[lastState.messages.length - 1];
                return { messages: [lastMessage] };
            }
            return { messages: [] };

        } catch (error) {
            if (error instanceof GraphRecursionError) {
                // If we have partial state, return the new messages generated so far
                if (lastState && lastState.messages) {
                    // The subAgent state includes our inputs. We only want the NEW messages.
                    // We slice from inputs.length to get the messages generated by the subAgent.
                    const newMessages = lastState.messages.slice(inputs.length);
                    
                    return { 
                        messages: [
                            ...newMessages,
                            new SystemMessage(RECURSION_ERROR_MARKER)
                        ] 
                    };
                }

                // Return a marker message to trigger conditional edge
                return { messages: [new SystemMessage(RECURSION_ERROR_MARKER)] };
            }
            throw error;
        }
    };

    // 3. Define the Fallback Node
    const fallbackNode = async (state: typeof MessagesAnnotation.State) => {
        const { messages } = state;
        console.log(messages);
        // Filter out the marker message from context
        const validMessages = messages.filter(m => m.content !== RECURSION_ERROR_MARKER);

        const fallbackPrompt = new HumanMessage(
            "The agent reached its step limit. Please provide the best answer you can based on the user query and context provided."
        );
        
        const plainModel = getLLM(params.modelName, params.apiKey, params.baseURL);
        const response = await plainModel.invoke([...validMessages, fallbackPrompt]);
        
        return { messages: [response] };
    };

    // 4. Define Conditional Logic
    const routeAfterSubAgent = (state: typeof MessagesAnnotation.State) => {
        const lastMessage = state.messages[state.messages.length - 1];
        if (lastMessage && lastMessage.content === RECURSION_ERROR_MARKER) {
            return "fallback";
        }
        return END;
    };

    // 5. Build the Parent Graph
    const workflow = new StateGraph(MessagesAnnotation)
        .addNode("fs_agent", callSubAgent)
        .addNode("fallback", fallbackNode)
        .addEdge(START, "fs_agent")
        .addConditionalEdges(
            "fs_agent",
            routeAfterSubAgent,
            {
                fallback: "fallback",
                [END]: END
            }
        )
        .addEdge("fallback", END);

    // Compile the parent graph
    const app = workflow.compile();

    // Construct the initial context
    const contextMessage = `You are analyzing the directory at: ${params.rootPath}

User query: ${params.query}

Use the available tools to search and analyze the files to answer the user's question.`;

    const result = await app.invoke({
        messages: [
            new HumanMessage(contextMessage),
        ],
    });

    const lastMessage = result.messages.at(-1);
    if (lastMessage && lastMessage instanceof AIMessage) {
        ensureUniqueId(lastMessage);
    }

    return (lastMessage?.content as string) ?? "";
}) satisfies RunAgentFunction<FsBasedAgentParams, string>;
